---
layout: post
title: "Dart 语言之从入门到放弃（万字长文）"
date: 2020-05-12
excerpt: ""
tags: [Android, Dart]
comments: true
---

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://juejin.im/post/5eb9f75bf265da7ba0582e25

前言
--

前一段时间系统学习 Flutter 时总结了一些 Dart 的基础知识，东西挺多的，建议收藏慢慢看😂，如果对你有帮助的话别忘了点赞关注啊。先放一个之前一篇文章的链接，看了之后应该可以让你对 Dart 的异步有更深入的了解：[那些你不知道的 Dart 细节之带你透彻理解异步](https://juejin.im/post/5e90213a51882573bc7c1570)。这是我前段时间学习 Flutter 写的 Flutter 版的玩安卓，感兴趣的可以去看看，很适合 Flutter 初学者：[历时三天，完成了 Flutter 版本的玩安卓](https://juejin.im/post/5e901fff51882573bd5f3f88)。 好了，废话不多说，开始进入正题吧，下面我将会从 Dart 的变量、内置类型、函数（方法）、流程控制语句、异常处理、类、泛型、库等方面进行描述，准备好了吗？要开车了，请系好安全带🐶，车速较快，请不要中途下车！！！

变量
--

### Hello World

学习一门语言一般都要从打印 “Hello World” 开始，那么就来看一下在 Dart 中应该怎样打印：

```
void main(){
  print("Hello World");
}
复制代码
```

和 Java 类似，Dart 执行也需要一个 main 方法，打印就要比 Java 稍微简单点了，直接进行 Print 就可以了。这里需要注意的是：**方法如果没有返回值的情况下可以省略 void**

### 变量的声明

真正要进入主题了。。。在 Dart 中变量的声明有三个关键字：var、dynamic 和 Object，三个关键字的使用情况各有千秋。下面来分别说一下：

#### var

首先说一下 var 关键字，了解过 Kotlin 的应该对这个关键字很熟悉，在 Kotlin 中 var 表示一个可变的变量（val 表示不可变的，相当于 final，这里不赘述），在 Dart 中，var 如果没有初始值，可以变成任何类型，但如果 var 有初始值，那么类型将被锁定。这是什么意思呢？看一下下面这段代码你就明白了：

```
main(){
  //print("Hello World");
  var data;
  data = 'zhujiang';
  data = 123;
  print(data);
}
复制代码
```

var 在没有初始值的时候是可以随意指定类型的，例如上面的代码，可以赋值为字符串，也可以赋值为 int。这里要注意：**Dart 中字符串可以使用单引号也可以使用双引号。**

上面代码没有赋初始值，下面赋初始值再看一下：

```
main(){
  //print("Hello World");
  var data = 1;
  data = 'zhujiang';
  data = 123;
  print(data);
}
复制代码
```

![](https://user-gold-cdn.xitu.io/2020/5/11/17203e96645202f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

大家可以看到，如果有初始值，就不可以改变类型了，正好印证了上面我们所说的类型被锁定。

#### Object

这个关键字大家应该都很熟悉，Java 中的所有对象的父类就是 Object。在 Dart 中 dynamic 指动态类型，会在**编译阶段检查类型**。Object 和 var 不同，即使赋了初始值，也同样可以指定别的类型：

```
Object data2 = 1234;
  data2 = 'dongnao';
  print(data2);
复制代码
```

上面所说的会在编译阶段检查类型指的是如果你调用一个本身没有的方法，可以直接报红，提醒你编写错误（var 也是在编译阶段检查类型）。

#### dynamic

我在学习 Dart 之前没有在别的语言见过这个关键字，对我而言比较陌生，这个关键字和 Object 非常相似，唯一的区别就是在**编译阶段不检查类型**。和 Object 恰恰相反，如果你调用一个本身没有的方法，不会报错，但是当你运行的时候才会抛异常。

### 变量的默认值

这个本来不想说的，但是发现和之前所学的不太一样，还是说一下吧。

> 在 Dart 中，没有初始化的变量自动获取一个默认值为 null
> 
> 一切皆对象，对象的默认值为 null

只要记着上面两句话就可以了，不要被之前的 Java 所禁锢，比如之前的 Boolean 值默认会是 false，但是在 Dart 中的 bool 值默认也是 null，记着，**一切皆对象，对象的默认值为 null**

### 变量 final 和 const

final 大家很了解，Java 中经常使用，const 相对就比较陌生了，下面说一下他们的共同点：

*   声明的类型可省略
    
    ```
    final fVariable1 = 'zhujiang';
    //  final String fVariable1 = 'zhujiang';
      const cVariable1 = 'zhujiang';
    //  const String cVariable1 = 'zhujiang';
    复制代码
    ```
    
*   初始化后不能再赋值
    
    ```
    fVariable1 = 'demo';
    cVariable1 = 'demo';
    复制代码
    ```
    
    上面初始化之后，这里就不可以赋值了，如果赋值即会报错
    
*   不能和 var 同时使用
    
    ```
    final var fVariable1 = 'zhujiang';
    const var fVariable1 = 'zhujiang';
    复制代码
    ```
    
    和 var 同时使用的话也会报错。
    

**下面再看一下他们的不同点：**

*   类级别常量，使用 static const
    
    ```
    static const int monday = 1;
    复制代码
    ```
    
    这里大家可以参照一下系统中的类，例如 DateTime。
    
*   const 可使用其他 const 常量的值来初始化其值
    
    ```
    const width = 100;
    const height = 100;
    const square = width * height;
    复制代码
    ```
    
*   使用 const 赋值声明，const 可省略
    
    ```
    const List clist = [1, 2, 3];
    //  const List clist = const [1, 2, 3];//dart 2之前，const赋值必须用const声明
    复制代码
    ```
    
*   可以更改非 final、非 const 变量的值，即使曾经具有 const 值
    
    ```
    var varList = const [1, 2, 3];
    final finalList = const [1, 2, 3];
    const constList = [1, 2, 3];
    varList = [1];
    //  constList = [1];
    //  finalList = [1];
    复制代码
    ```
    
*   const 导致的不可变性是可传递的
    
    ```
    final List ls = [1, 2, 3];
      ls[1] = 4;
      print(ls);
      const List ls1 = [1, 2, 3];
    //  ls1[1] = 4;
    复制代码
    ```
    
*   相同的 const 常量不会在内存中重复创建
    
    ```
    final finalList1 = [1, 2];
      final finalList2 = [1, 2];
      print(identical(finalList1, finalList2)); //identical用于检查两个引用是否指向同一个对象
    
      const constList1 = [1, 2];
      const constList2 = [1, 2];
      print(identical(constList1, constList2)); 
    复制代码
    ```
    
    上面代码的运行结果是 false 和 ture，也印证了上面所说的。
    
*   const 需要是编译时常量
    
    ```
    final DateTime finalDateTime = DateTime.now();
      //  const DateTime constDateTime = DateTime.now();//DateTime.now() 是运行期计算出来的值
    复制代码
    ```
    

### 小总结

本小节简单说明了在 Dart 中变量的一些细节问题，如有补充或者错误可直接在评论区说出来，不要给我面子😂。

内置类型
----

### 概述

在 Dart 中，内置类型有以下几种：**Numbers 数值、Strings 字符串、Booleans 布尔值、Lists 列表 (数组)、Sets 集合、Maps 集合、Runes 符号字符、Symbols 标识符**。

### num, int, double

int 和 double 大家都很熟悉，int 还是整数值，double 是 64-bit 双精度浮点数。这里需要着重看一下 **num**，**int 和 double 是 num 的子类**。剩下的就没什么好说的了，其他的使用方法和 Java 基本一样，只是可以直接定义 num 类型的数据, 剩下的大家直接看下面的代码应该就明白了：

```
int i = 1; //整数值
  double d = 1.0; //double  64-bit (双精度) 浮点数
  int bitLength = i.bitLength;
  print('bitLength: ${bitLength}'); //bitLength判断int值需要多少bit位
  double maxFinite = double.maxFinite;
  print('maxFinite: ${maxFinite}'); //maxFinitedouble的最大值
  //int和double都是num的子类
  num n1 = 1;
  num n2 = 1.0;
  //支持十进制、十六进制
  int i1 = 0xfff;
  //科学计数法
  double d1 = 1.2e2; //120.0
  //转换
  //String->int
  int i2 = int.parse('1');
  double d2 = 1; //当double的值为int值时，int自动转成double
  print('d2: ${d2}');
//  int i2 = int.tryParse('1.0');//返回null
复制代码
```

### String

*   Dart 字符串是 UTF-16 编码的字符序列，可以使用单引号或者双引号来创建字符串
    
    ```
    main(){
      String a = 'zhujiang';
      String b = "zhujiang";
    }
    复制代码
    ```
    
*   可以使用三个单引号或者双引号创建多行字符串对象
    
    ```
    String c = "dd"
        "sssdffg"
      "vftgt";
      String d = '''ssss
      fffffffgg
      grrrr''';
    复制代码
    ```
    
*   可以使用 r 前缀创建” 原始 raw” 字符串。
    
    ```
    String e = '''ssss
      fff\nffffgg
      grrrr''';
      String f = r'''ssss
      fff\nffffgg
      grrrr''';
      print(e);
      print(f);
    复制代码
    ```
    
    这里需要说明一下，如果使用 r 前缀，即是原始字符串，\n 换行会直接打印出来而不会实现换行，下面是执行结果：
    
    ```
    lib/2-type.dart: Warning: Interpreting this as package URI, 'package:darttest/2-type.dart'.
    ssss
      fff
    ffffgg
      grrrr
    ssss
      fff\nffffgg
      grrrr
    复制代码
    ```
    
*   可以在字符串中使用表达式： ${expression}, 如果表达式是一个标识符，可以省略 {}，如果表达式的结果为一个对象，则 Dart 会调用对象的 toString() 函数来获取一个字符串。
    
    ```
    print("object:$c");
    复制代码
    ```
    

这里既然已经说到 String 了，那就再说一下 StringBuffer 吧，使用方法和 Java 一样，但是可以省略 new 关键字，还可以进行链式调用：

```
StringBuffer stringBuffer = StringBuffer();
  stringBuffer..write("sss")..write("ssss");
复制代码
```

### bool

这里的 bool 相当于 Java 中 boolean，这里只需要记着 **bool 对象未初始化的默认值是 null**（上一篇文章中提到过）

### List

*   Dart 中可以直接打印 list 包括 list 的元素，List 也是对象（java 中直接打印 list 结果是地址值）。
    
    ```
    print(List)
    复制代码
    ```
    
    这里会直接输出 List。
    
*   Dart 中 List 的下标索引和 java 一样从 0 开始
    
*   和 java 一样支持泛型。
    
*   有增删改查，支持倒序，自带排序、洗牌，可使用 + 将两个 List 合并
    
    ```
    //常用方法 增删改查，排序，洗牌，复制子列表
      var list4 = [];
      //增
      list4.add(1);
      print('add 1 :${list4}');
      //删
      list4.remove(5);
      print('remove 5 :${list4}');
      list4.removeAt(2);
      print('remove at 0 :${list4}');
      //改
      list4[4] = 5;
      print('update list4[4] to 5 :$list4}');
      //range
      list4.fillRange(0, 3, 9);
      print('fillRange update list4[0]-list4[2] to 9 :$list4}');
      Iterable getRange = list4.getRange(0, 3);
      print('getRange list4[0]-list4[2] :$getRange}');
      //查
      var contains = list4.contains(5);
      print('list4 contains 5 :${contains}');
      var indexOf = list4.indexOf(1);
      print('list4 indexOf 1 :${indexOf}');
      int indexWhere = list4.indexWhere((test) => test == 5);
      print('list4 indexWhere 5 :${indexWhere}');
      //排序
      list4.sort();
      print('list4 sort :${list4}');
      //洗牌
      list4.shuffle();
      print('list4 shuffle :${list4}');
      //复制子列表
      var list5 = list4.sublist(1);
      print('sublist(1) list5 :${list5}');
      //操作符
      var list6 = [8, 9];
      print('list6 :${list6}');
      var list7 = list5 + list6;
      print('list5 + list6 :${list7}');
    复制代码
    ```
    
    这里的代码比较长，但是很好理解，就是一个集合的增删改查和一些比较常用的方法，大家可以自己手写一下加深理解。
    

### Map

map 这里就不多说了，和 Java 类似

### Set

Set 这里其实也和 Java 差不多，但是有几个地方需要说明一下：

*   set1.difference(set2): 返回 set1 集合里有但 set2 里没有的元素集合
*   set1.intersection(set2)：返回 set1 和 set2 的交集
*   set1.union(set2)：返回 set1 和 set2 的并集
*   set1.retainAll()：set1 只保留某些元素 (要保留的元素要在原 set 中存在）

这几个方法非常好用，简单写一下伪代码大家看一下吧：

```
var difference12 = set1.difference(set2);
  var difference21 = set2.difference(set1);
  print('set1 difference set2 :${difference12}'); //返回set1集合里有但set2里没有的元素集合
  print('set2 difference set1 :${difference21}'); //返回set2集合里有但set1里没有的元素集合
  var intersection = set1.intersection(set2);
  print('set1 set2交集 :${intersection}'); //返回set1和set2的交集
  var union = set1.union(set2);
  print('set1 set2并集 :${union}'); //返回set1和set2的并集
  set2.retainAll(['aa', 'flutter']); //只保留(要保留的元素要在原set中存在）
  print('set2只保留aa flutter :${set2}');
复制代码
```

### Runes

表示符文的意思，用于在字符串中表示 Unicode 字符。使用 String.fromCharCodes 显示字符图形。如果非 4 个数值，需要把编码值放到大括号中。

```
Runes runes = new Runes('\u{1f605} \u6211‘);
  var str1 = String.fromCharCodes(runes);  
  print(str1);
复制代码
```

直接这样写就可以了，下面看一下打印效果：

```
😅 我
复制代码
```

直接可以打印出表情，有表情需求的可以直接使用 Runes。

### Symbol

Symbol 标识符，以前主要是反射使用，但是现在 mirrors 模块已经被移除，所以没啥大用了，大家只要知道有这么一个内置类型就可以了。

方法
--

方法这一块很重要，写代码离不开方法啊，继续开车，抓稳了！

### 定义

*   可在函数内定义
    
    ```
    void main(){
      void test(){
      }
    }
    复制代码
    ```
    
    和 Java 不同，Dart 中的函数可以定义在函数内部（和 Java 的匿名内部类别搞混了）
    
*   定义函数时可省略类型（不建议）
    
    ```
    main(){
      test(){
        // return null;
      }
    }
    复制代码
    ```
    
    上面的函数可以写成下面这样，Dart 中函数是 Function 类型的对象。所有的函数都返回一个值。如果没有指定返回值，则 默认把语句 return null; 作为函数的最后一个语句执行。
    
*   支持缩写语法 => （Kotlin 是用 = 来实现）
    
    ```
    main(){
      print(test1());
    }
    test()=> "zhujiang";
    String test1(){
      return "zhujiang";
    }
    复制代码
    ```
    
    上面代码中的 test() 和 test1() 效果是一样的，“=>” 相当于大括号和 return
    

### 可选参数

既然是函数，那么肯定要传参，我在经过 Java 构造方法的摧残之后，看这个功能的时候泪流满面😭。为什么会这样呢？下面先来看一个咱们的 Java 类的构造函数：

```
public class Test {

    private String name;
    private int age;
    private String address;

    public Test(String name, int age, String address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }
    
    public Test(String name, String address) {
        this.name = name;
        this.address = address;
    }

    public Test(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Test(String name) {
        this.name = name;
    }
}
复制代码
```

一个非常简单的构造方法，只是想要传参数形式多一点，竟然需要写这么多重载方法。。。那么下面咱们来看一下拿 Dart 写的同样功能的代码：

```
class Test{
  String name;
  int age;
  String address;
  Test(this.name, {this.age, this.address});
}
复制代码
```

What？竟然可以这样？是的，可以这样。下面来详细说一下函数的可选参数。

#### 可选命名参数

其实上面构造方法我使用的就是可选命名参数，写的时候其实很简单，只需要加上大括号就行。下面是使用方法：

```
main() {
  print(add(a: 1, b: 3));
}

int add({int a = 1, int b}) {
  return a + b;
}
复制代码
```

上面的 add 方法调用的时候可以不填参数，也可以填任何一个参数，也可以将参数都填上。这里要注意：

*   **如果 a 不填的话，默认值就是 1，如果 b 不填，默认值就是 null。**
*   **传参数的时候一定要记得写 a：，不然会报错。**

#### 可选位置参数

和上面的可选命名参数不同，上面的函数如果想调用，必须命名再加上冒号才能使用，可选位置参数就不需要了。这里和上面一样，默认值可加可不加：

```
int add2(int a,[int b = 2,int c = 3]) {
  return a + b;
}
复制代码
```

下面是上面 add2() 方法的几种调用方式：

```
print(add2(1));
  print(add2(1,2));
  print(add2(1,1,3));
复制代码
```

#### 注意

上面的可选命名参数和可选位置参数，可使用 list 或 map 作为默认值，但必须是 const。

```
int add3({List a = const [1,2,3], int b = 2}) {
  return b;
}
复制代码
```

### 匿名函数

可赋值给变量，通过变量调用。可在其他函数中直接调用或传递给其他函数。匿名函数分为**无参匿名函数和有参匿名函数**：

*   **无参匿名函数**
    
    ```
    var printFun = () => print("**无参匿名函数**");
    复制代码
    ```
    
*   **有参匿名函数**
    
    ```
    var printFun2 = (name) => print("**有参匿名函数 $name**");
    printFun2("sss");
    复制代码
    ```
    

这里还有一个小的**知识点**：_**可以通过 () 调用，不推荐。**_

```
(() =>print("***可以通过()调用，不推"))();
复制代码
```

### 闭包

这里感觉没什么好说的，大家直接看代码应该就可以理解：

```
Function makeAddFunc(int x) {
  x++;
  return (int y) => x + y;
}
var makeAddFun = makeAddFunc(11);
print(makeAddFun(10));
复制代码
```

就是创建一个方法，返回的也是一个方法，可以再继续调用。

### 函数别名

用 **typedef** 给函数起一个别名，使用比较方便。例如定义一个方法的回调，直接使用别名定义。**没返回值，则只要参数匹配就行了，如果定义了返回值，则返回值不一样会报错。**

```
typedef Fun1(int a, int b);
typedef Fun2<T, K>(T a, K b);
int add(int a, int b) {
  print('a + b');
  return a + b;
}
class Demo1 {
  Demo1(int f(int a, int b), int x, int y) {
    var sum = f(x, y);
    print("sum1 = $sum");
  }
}
class Demo2 {
  Demo2(Fun1 f, int x, int y) {
    var sum = f(x, y);
    print("sum2 = $sum");
  }
}
class Demo3 {
  Demo3(Fun2<int, int> f, int x, int y) {
    var sum = f(x, y);
    print("sum3 = $sum");
  }
}
复制代码
```

上面代码就是定义函数别名的方法，下面是调用方法：

```
Fun1 fun1 = add(11, 12);
复制代码
```

操作符、流程控制语句、异常
-------------

这一小节看着东西应该挺多，其实很简单，好多都和 Java 基本一致。

### 操作符

![](https://user-gold-cdn.xitu.io/2020/5/11/17203ee5d014fb52?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

上面这幅图中就是 Dart 中的操作符，标为黑色的操作符和 Java 中使用基本一样，这里也就不过多赘述，咱们来仔细看看标红 Java 中没有的操作符：

*   后缀操作： **?.**
    
    如果写过 Kotlin 的话，可以跳过这段了，这里的问号点和 Kotlin 中基本一致，都是为了判空而出现的，那么下面来看一下使用方式吧：
    
    ```
    main() {
      String a;
      print(a.length != null ? a.length : '');
    }
    复制代码
    ```
    
    上面就是咱们平时写的代码，一个三目表达式来进行判空。但是在 Dart 中可以不这样写，可以直接使用问号点。
    
    ```
    main() {
      String a;
      //print(a.length != null ? a.length : '');
      print(a?.length);
    }
    复制代码
    ```
    
    是不是很方便？以后判空可以直接使用 **"?."** 了
    
*   除（取整）：**~/**
    
    这个操作符其实很简单，只是对数字进行取整，下面是实例代码：
    
    ```
    print(1/2);
    print(1~/2);
    复制代码
    ```
    
    上面代码的输出值是 0.5 和 0
    
*   类型操作：**as**
    
    这个和 Kotlin 中的 as 也基本一样，是对数据进行类型转换，很简单，直接看代码：
    
    ```
    num n = 1;
    int n2 = n as int;
    复制代码
    ```
    
*   类型操作： **is**
    
    ```
    num n1 = 1.0;
    if(n1 is int){
      print("int");
    }else{
      print("double");
    }
    复制代码
    ```
    
*   类型操作：**is!**
    
    从名称上就可以知道和上面的 is 正好相反，就不写代码验证了。
    
*   判空：**??**
    
    这个上面也写出来了，意思就是判空，下面直接看一下使用方法吧：
    
    ```
    bool aaa;
    aaa = aaa ?? false;
    复制代码
    ```
    
*   级联：**..**
    
    这个其实就是链式调用，之前的文章中写过，当时的例子是 StringBuffer：
    
    ```
    StringBuffer stringBuffer = StringBuffer();
     stringBuffer..write("sss")..write("ssss");
    复制代码
    ```
    

操作符就说到这里吧，掌握好操作符在写代码的时候会事半功倍的，希望大家都能掌握好。

### 流程控制语句

这个，怎么说，稍微提一下吧，这个是基础的基础，Dart 中的流程控制语句和 Java 基本一样，直接进行使用就行。

不是不想写，**if 语句、for 循环、while 循环、brake、continue、switch、case**，没了，这就是 Dart 的流程控制语句，如出一辙。跳过。

### 异常

Dart 提供了 Exception 和 Error 类型， 以及一些子类型。还可以定义自己的异常类型。但是，Dart 代码可以抛出任何非 null 对象为异常，不仅仅是实现了 Exception 或者 Error 的对象。

下面这幅图是 Dart 中的 **Exception** ：

![](https://user-gold-cdn.xitu.io/2020/5/11/17203ee8d729c547?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

下面这幅图是 Dart 中的 **Error**：

![](https://user-gold-cdn.xitu.io/2020/5/11/17203eeb4ff57cde?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### 抛出异常

*   这个和 Java 中写法一样，所有的 Dart 异常是非检查异常。 方法不一定声明了他们所抛出的异常， 并且你不要求捕获任何异常。
    
    ```
    // 抛出Exception 对象
    // throw new FormatException(‘格式异常');
    
    // 抛出Error 对象
    // throw new OutOfMemoryError();
    复制代码
    ```
    
*   Dart 代码可以抛出任何非 null 对象为异常，不仅仅是实现了 Exception 或者 Error 的对象。
    
    ```
    // 抛出任意非null对象
    // throw '这是一个异常';
    复制代码
    ```
    

#### 捕获异常

*   所有的 Dart 异常是非检查异常。 方法不一定声明了他们所抛出的异常， 并且你不要求捕获任何异常。可以使用 on 或者 catch 来声明捕获语句，也可以 同时使用。使用 on 来指定异常类型，使用 catch 来 捕获异常对象。
    
    ```
    try {
        throw new OutOfMemoryError();
      } on OutOfMemoryError {
        print('没有内存了');
      }
    复制代码
    ```
    
*   catch() 可以带有一个或者两个参数， 第一个参数为抛出的异常对象， 第二个为堆栈信息 (一个 StackTrace 对象)。
    
    ```
    try {
        throw new OutOfMemoryError();
      } catch (e, s) {
        print('Exception details: $e');
        print('Stack Trace: $s');
      } finally {
        print('end');
      }
    复制代码
    ```
    
*   可以使用 rethrow 把捕获的异常重新抛出。
    
    ```
    try {
        throw new OutOfMemoryError();
      } catch (e, s) {
        print('Exception details: $e');
        print('Stack Trace: $s');
        rethrow；
      }
    复制代码
    ```
    

类的点点滴滴
------

前几小节分别讲解了 Dart 中的变量、内置类型、函数（方法）、操作符、流程控制语句和异常，对 Dart 的基本语法已经有了很多的了解，那么接来说一下 Dart 中的类。

### 构造函数

前几篇文章中在讲函数（方法）的一篇中提到过，这里再说一下吧，首先来看一下 Java 中构造函数的写法：

```
class Point {
  double x;
  double y;

  Point(int x, int y) {
    this.x = x;
    this.y = y;
  }
}
复制代码
```

下面是 dart 中的建议写法：

```
class Point {
  num x;
  num y;
  Point(this.x, this.y);
}
复制代码
```

### 命名构造函数

使用命名构造函数可以为一个类实现多个构造函数， 或者使用命名构造函数来更清晰的表明你的意图。

```
class Point { 
  num x; 
  num y; 

  Point(this.x, this.y); 

  //命名构造函数
  Point.fromJson(Map json) { 
    x = json['x']; 
    y = json['y']; 
  } 
}
复制代码
```

### 重定向构造函数

一个重定向构造函数是没有代码的，在构造函数声明后，使用 冒号调用其他构造函数。

```
class Point { 
  num x; 
  num y; 

  Point(this.x, this.y); 

  //重定向构造函数，使用冒号调用其他构造函数
  Point.alongXAxis(num x) : this(x, 0);
}
复制代码
```

### 初始化列表

在构造函数体执行之前可以初始化实例参数。 使用逗号分隔初始化表达式。初始化列表非常适合用来设置 final 变量的值。

```
import 'dart:math';

class Point {
  //final变量不能被修改，必须被构造函数初始化
  final num x;
  final num y;
  final num distanceFromOrigin;

  //初始化列表
  Point(x, y)
      : x = x,
        y = y,
        distanceFromOrigin = sqrt(x * x + y * y);
}
复制代码
```

### 调用超类构造函数

首先来建立一个超类（父类），下面的代码都继承自此类：

```
class Parent {
  int x;
  int y;

  //父类命名构造函数不会传递  
  Parent.fromJson(x, y)
      : x = x,
        y = y {
    print('父类命名构造函数');
  }
}
复制代码
```

*   超类命名构造函数不会传递，如果希望使用超类中定义的命名构造函数创建子类，则必须在子类中实现该构造函数。
    
    ```
    class Child extends Parent {
      int x;
      int y;
    
      Child.fromJson(x, y) 
    	 : x = x,
    	   y = y,
        print('子类命名构造函数');
      }
    }
    复制代码
    ```
    
*   如果超类没有默认构造函数， 则你需要手动的调用超类的其他构造函数, 调用超类构造函数的参数无法访问 this。
    
    ```
    class Child extends Parent {
      int x;
      int y;
      //若超类没有默认构造函数， 需要手动调用超类其他构造函数
      Child(x, y) : super.fromJson(x, y) {
        //调用父类构造函数的参数无法访问 this
        print('子类构造函数');
      }
    }
    
    复制代码
    ```
    
*   在构造函数的初始化列表中使用 super()，需要把它放到最后。
    
    ```
    class Child extends Parent {
      int x;
      int y;
     
      Child.fromJson(x, y) 
    	 : x = x,
    	   y = y,
    	   super.fromJson(x, y) {
        print('子类命名构造函数');
      }
    }
    
    复制代码
    ```
    

### 常量构造函数

定义 const 构造函数要确保所有实例变量都是 final。 const 关键字放在构造函数名称之前。

```
class Point2 {
  //定义const构造函数要确保所有实例变量都是final
  final num x;
  final num y;
  static final Point2 origin = const Point2(0, 0);

  //const关键字放在构造函数名称之前，且不能有函数体
  const Point2(this.x, this.y);
}
复制代码
```

### 工厂构造函数 (Dart 中的单例)

工厂构造函数是一种构造函数，与普通构造函数不同，工厂函数不会自动生成实例, 而是通过代码来决定返回的实例对象。如果一个构造函数并不总是返回一个新的对象（**单例**），则使用 factory 来定义这个构造函数。工厂构造函数无法访问 this。

```
class Singleton {
  String name;
  //工厂构造函数无法访问this，所以这里要用static
  static Singleton _cache; 

  //工厂方法构造函数，关键字factory
  factory Singleton([String name = 'singleton']) =>
      Singleton._cache ??= Singleton._newObject(name);

  //定义一个命名构造函数用来生产实例
  Singleton._newObject(this.name);
}
复制代码
```

### Setter 和 Getter

在 Java 中 get 和 set 方法可以直接生成，在 Dart 中无需自己定义。每个实例变量都隐含的具有一个 getter， 如果变量不是 final 的则还有一个 setter。可以通过实行 getter 和 setter 来创建新的属性， 使用 get 和 set 关键字定义 getter 和 setter。可以开始使用实例变量，后来可以把实例变量用函数包裹起来，而调用你代码的地方不需要修改。下面是代码实例：

```
class Rectangle {
  num left;
  num top;
  num width;
  num height;

  Rectangle(this.left, this.top, this.width, this.height);

  num get right => left + width;
  set right(num value) => left = value - width;
  num get bottom => top + height;
  set bottom(num value) => top = value - height;
}
复制代码
```

### 抽象类（接口）

*   不能被实例化，除非定义一个工厂构造函数。
    
    这个很好理解，在 Java 中的抽象类也同样不可实例化。
    
*   抽象类通常用来定义接口， 以及部分实现。
    
    在 Dart 中**没有 interface** 这个关键字，只有 **abstract**，所以可以使用 **abstract** 来生成接口：
    
    ```
    abstract class Demo{
      void zhujiang();
    }
    
    class Zhu implements Demo{
      @override
      void zhujiang() {}
    }
    复制代码
    ```
    
*   抽象类通常具有抽象方法，抽象方法不需要关键字，以分号结束即可。
    
    其实上面代码也可以用作这个实例，只需要把 implements 变成 **extends** 即可：
    
    ```
    class Zhu extends Demo{
      @override
      void zhujiang() {}
    }
    复制代码
    ```
    
*   接口方式使用时，需要重写抽象类的成员变量和方法，包括私有的。
    
*   一个类可以 implement 一个普通类。Dart 任何一个类都是接口。
    
*   一个类可以 implement 多个接口。
    

最后几个说的其实有点绕，说白了就是可以实现多个，这里需要注意的是：**implement 只是实现接口，你需要重写接口中的方法，不然是不会执行的**。还有一点是如果想 extents 多个类的话需要使用 **with** 关键字。说了这么多不如直接看代码，看代码应该好理解一些：

```
abstract class Demo{
  void zhujiang();
}

abstract class Demo2{
  void zhujiang();
}

abstract class Demo3{
  void zhujiang();
}

class Zhu extends Demo with Demo2,Demo3 implements Demo3,Demo2{
  @override
  void zhujiang() {}
}
复制代码
```

### 可调用类

实现 call() 方法可以让类像函数一样能够被调用。这个很简单，直接上代码：

```
class ClassFunction {
  call(String a, String b, String c) => '$a $b $c!';
}

main() {
  var cf = new ClassFunction();
  var out = cf("aaa","flutter","damon");
  print('$out');
  print(cf.runtimeType);
  print(out.runtimeType);
  print(cf is Function);
}
复制代码
```

下面是打印结果：

```
lib/5.dart: Warning: Interpreting this as package URI, 'package:darttest/5.dart'.
aaa flutter damon!
ClassFunction
String
false
复制代码
```

### Mixin

*   子类没有重写超类 A 方法的前提下，如果 2 个或多个超类拥有相同签名的 A 方法，那么子类会以继承的最后一个超类中的 A 方法为准。
*   如果子类自己重写了 A 方法则以本身的 A 方法为准。

在这里先不过多解释 Minxin，我的理解就类似于策略模式，抽出不变的为接口，然后多实现。这里先不写了，如果有可能的话等专门写一篇介绍 Dart 中的 Minxin 的文章吧。

Dart 泛型
-------

*   Java 中的泛型信息是编译时的，泛型信息在运行时是不存在的
*   Dart 的泛型类型是固化的，在运行时也有可以判断的具体类型

```
var names = List<String>();
print(names is List<String>);//true
print(names.runtimeType); // List<String> 
复制代码
```

在 Java 中，可以测试对象是否为 List，但无法测试它是否是 List。但是在 Dart 中是预编译的。

其他的泛型使用方法和 Java 中的类似，这里就不赘述了。

Dart 中的库
--------

这个平时用的非常多，而且非常实用，Dart 有你不知道的但又非常好用的语法，继续出发！

### 库 - 使用核心库

使用 import 关键字来载入库：

```
import "dart:math";

void main() {
  print(sqrt(4));//开平方 2.0
}
复制代码
```

对于内置的库，URI 使用特殊的 dart: scheme。对于其他的库，你可以使用文件系统路径或者 package: scheme。

### 库 - 载入第三方库

在 Flutter 中想使用第三方库的话需要在 **pubspec.yaml** 中的 **dependencies** 中添加依赖：

```
dependencies:
  flutter:
    sdk: flutter

  cupertino_icons: ^0.1.0
  dio: ^2.1.0
复制代码
```

添加完成之后点击右上角的 **packages get** 进行导入依赖。下面是三方哭调用方法：

```
import "package:dio/dio.dart";

void main() {
  getHttp();
}

void getHttp() async {
  try {
    Response response = await Dio().get("https://www.baidu.com");
    print(response);
  } catch (e) {
    print(e);
  }
}
复制代码
```

这里给大家一个网站，需要寻找第三方库的时候直接在里面搜索即可：[pub.dev/](https://pub.dev/)

### 库 - 指定库前缀

在 Java 编码过程经常会出现一个类中调用两个类中相同名字的方法，这时就需要全限定名称来调用了，但是在 Dart 中是不需要的：

```
import 'MyLib1.dart' as lib1; 
import 'MyLib2.dart' as lib2; 

void main() {
  var myLib = lib1.MyLib();
  var myLib2 = lib2.MyLib();
}
复制代码
```

上面代码中 MyLib1.dart 和 MyLib2.dart 都有一个名字为 MyLib 的类。

### 库 - 选择性载入

*   show - 只载入库的某些部分
*   hide - 筛选掉库的某些部分

```
import 'Mylib1.dart' as lib1 show Test;
import 'Mylib2.dart' as lib2 hide Test;

var test = lib1.Test();
var lib = lib2.MyLib();
复制代码
```

如果只使用库的一部分功能，则可以选择需要导入的 内容。

### 库 - 延迟载入

1.  使用 deferred as 导入
2.  使用标识符调用 loadLibrary() 加载库

```
import 'MyLib1.dart' deferred as lazyLib;

void main() {
  lazyLoad();
}
lazyLoad() async {
  await lazyLib.loadLibrary();
  var t = lazyLib.Test();
  t.test();
}
复制代码
```

使用 await 关键字暂停代码执行一直到库加载完成。可提高程序启动速度。用在不常使用的功能和载入时间过长的包。

### 库 - 自定义库

1.  首先将一个文件作为 library：
    
    ```
    library mylib;
    
    part 'util.dart';
    part 'tool.dart';
    
    void printMyLib() => print('mylib');
    复制代码
    ```
    
2.  然后使用 part 把一个库分开到多个 Dart 文件中。
    
    ```
    part of mylib;
    void printTool() => print('tool');
    复制代码
    ```
    
    ```
    part of mylib;
    void printUtil() => print('util');
    复制代码
    ```
    
3.  import 不会完全共享作用域，而 part 之间是完全共享的。如果说在 A 库中 import 了 B 库，B 库 import 了 C 库，A 库是没有办法直接使用 C 库的对象的。而 B,C 若是 A 的 part，那么三者共享所有对象。并且包含所有导入。
    
    ```
    import 'mylib/mylib.dart';
    
    void main() {
      printMyLib();
      printUtil();
      printTool();
    }
    复制代码
    ```
    

总结
--

这一篇文章之前写了好久，本来想每个小节分成一篇文章发布的，这样就会有好几篇文章了😂，但又想了想那样不太厚道，直接全写完再发吧。看掘金中都是大佬，各种一线大厂技术、各种阿里腾讯名义的文章。。。比不了比不了，只是一个小破公司的一个一直在努力前进的小码农，写的文章也许不太好，但也都算用心了，希望大家能够喜欢，最后说一句，别忘了点赞关注评论啊😂😂😂，感激不尽。